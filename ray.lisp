(in-package #:minilight)

(defclass ray ()
  ((ox :initarg :ox :type single-float) ;origin
   (oy :initarg :oy :type single-float)
   (oz :initarg :oz :type single-float)
   (dx :initarg :dx :type single-float) ;direction
   (dy :initarg :dy :type single-float)
   (dz :initarg :dz :type single-float))
  (:default-initargs :ox 0.0 :oy 0.0 :oz 0.0
                     :dx 1.0 :dy 1.0 :dz 1.0))

(defclass slope-ray (ray)
  (;;inverse direction
   (idx :initarg :idx :type single-float) 
   (idy :initarg :idy :type single-float)
   (idz :initarg :idz :type single-float)
   ;;slopes
   (dxdy :initarg :dxdy :type single-float) 
   (dydx :initarg :dydx :type single-float)
   (dydz :initarg :dydz :type single-float)
   (dzdy :initarg :dzdy :type single-float) 
   (dxdz :initarg :dxdz :type single-float)
   (dzdx :initarg :dzdx :type single-float)
   ;;precomputation
   (cxy :initarg :cxy :type single-float) 
   (cxz :initarg :cxz :type single-float)
   (cyx :initarg :cyx :type single-float)
   (cyz :initarg :cyz :type single-float)
   (czx :initarg :czx :type single-float)
   (czy :initarg :czy :type single-float)
   (classification :initarg :classification :type symbol :reader classification)))

(defun classify-ray (dx dy dz)
  (declare (single-float dx dy dz))
  (macrolet ((if-xor (a b and-case b-case a-case &body else-case)
               (let ((ea (gensym))
                     (eb (gensym)))
                 `(let ((,ea ,a)
                        (,eb ,b))
                    (if (and ,ea ,eb)
                        ,and-case
                        (if ,eb
                            ,b-case
                            (if ,ea ,a-case ,@else-case)))))))
    (symbol-macrolet ((dx=0 (zerop dx))
                      (dy=0 (zerop dy))
                      (dz=0 (zerop dz)))
      (if (minusp dx)
          ;; M _ _
          (if (minusp dy)
              ;; M M _
              (if (minusp dz)
                  'MMM
                  (if dz=0 'MMO 'MMP))
              ;; M P _
              (if (minusp dz)
                  (if dy=0 'MOM 'MPM)
                  (if-xor dy=0 dz=0
                          'MOO 'MPO 'MOP 'MPP)))
          ;; P _ _
          (if (minusp dy)
              ;; P M _
              (if (minusp dz)
                  (if dx=0 'OMM 'PMM)
                  (if-xor dx=0 dz=0
                          'OMO 'PMO 'OMP 'PMP))
              ;; P P _
              (if (minusp dz)
                  (if-xor dy=0 dx=0
                          'OOM 'OPM 'POM 'PPM)
                  (if dx=0
                      (if dy=0
                          'OOP
                          (if dz=0 'OPO 'OPP))
                      (if-xor dz=0 dy=0
                              'POO 'POP 'PPO 'PPP))))))))

(defmethod initialize-instance :after ((ray slope-ray) &key ox oy oz dx dy dz &allow-other-keys)
  (with-slots (idx idy idz
                   dxdy dydx dydz dzdy dxdz dzdx
                   cxy cxz cyx cyz czx czy classification) ray
    (flet ((inverse (n)
             (declare (single-float n))
             (if (zerop n)
                 0.0
                 (/ 1.0 n)))
           (compute (a slope c)
             (declare (single-float a slope c))
             (- a (* slope c))))
      (setf idx (inverse dx)
            idy (inverse dy)
            idz (inverse dz))
      (setf dxdy (* dx idy)
            dydx (* dy idx)
            dydz (* dy idz)
            dzdy (* dz idy)
            dxdz (* dx idz)
            dzdx (* dz idx))
      (setf cxy (compute oy dydx ox)
            cxz (compute oz dzdx ox)
            cyx (compute ox dxdy oy)
            cyz (compute oz dzdy oy)
            czx (compute ox dxdz dz)
            czy (compute oy dydz dz))
      (setf classification (classify-ray dx dy dz)))))

(defun make-slope-ray (ox oy oz dx dy dz)
  "Create a SLOPE-RAY as defined by
'Fast Ray/Axis-Aligned Bounding Box Overlap Tests using Ray Slopes'
M. Eisemann, T. Grosch, S. MÃ¼ller, M. Magnor,
Journal of Graphic Tools, vol. 12, no. 4
http://www.cg.cs.tu-bs.de/people/eisemann/"
  (make-instance 'slope-ray
                 :ox ox :oy oy :oz oz
                 :dx dx :dy dy :dz dz))

(defmethod intersect-p ((ray slope-ray) (box aa-bbox) &optional last-hit)
  (declare (ignore last-hit))
  (with-slots (lx ly lz hx hy hz) box
    (with-slots (ox oy oz idx idy idz
                    dxdy dydx dydz dzdy dxdz dzdx
                    cxy cxz cyx cyz czx czy classification) ray
      (case classification
        ;;; TODO: macro-ify case stanza creation.
        (MMM (when (not (or (< ox lx) (< oy ly) (< oz lz)
                            (plusp (+ (- (* dydx lx) hy) cxy))
                            (plusp (+ (- (* dxdy ly) hx) cyx))
                            (plusp (+ (- (* dydz lz) hy) czy))
                            (plusp (+ (- (* dzdy ly) hz) cyz))
                            (plusp (+ (- (* dzdx lx) hz) cxz))
                            (plusp (+ (- (* dxdz lz) hx) czx))))
               (max (* (- hx ox) idx) 
                    (* (- hy oy) idy)
                    (* (- hz oz) idz))))
        (MMP (when (not (or (< ox lx) (< oy ly) (> oz hz)
                            (plusp (+ (- (* dydx lx) hy) cxy))
                            (plusp (+ (- (* dxdy ly) hx) cyx))
                            (plusp (+ (- (* dydz hz) hy) czy))
                            (minusp (+ (- (* dzdy ly) lz) cyz))
                            (minusp (+ (- (* dzdx lx) lz) cxz))
                            (plusp (+ (- (* dxdz lz) hx) czx))))
               (max (* (- hx ox) idx)
                    (* (- hy oy) idy)
                    (* (- lz oz) idz))))
        (MPM (when (not (or (< ox lx) (> oy ly) (< oz hz)
                            (minusp (+ (- (* dydx lx) ly) cxy))
                            (plusp (+ (- (* dxdy hy) hx) cyx))
                            (minusp (+ (- (* dydz lz) ly) czy))
                            (plusp (+ (- (* dzdy hy) hz) cyz))
                            (plusp (+ (- (* dzdx lx) hz) cxz))
                            (plusp (+ (- (* dxdz lz) hx) czx))))
               (max (* (- hx ox) idx)
                    (* (- ly oy) idy)
                    (* (- hz oz) idz))))
        (MPP (when (not (or (< ox lx) (> oy hy) (> oz hz)
                            (minusp (+ (- (* dydx lx) ly) cxy))
                            (plusp (+ (- (* dxdy hy) hx) cyx))
                            (minusp (+ (- (* dydz hz) ly) czy))
                            (minusp (+ (- (* dzdy hy) lz) cyz))
                            (minusp (+ (- (* dzdx lx) lz) cxz))
                            (plusp (+ (- (* dxdz hz) hx) czx))))
               (max (* (- hx ox) idx)
                    (* (- ly oy) idy)
                    (* (- lz oz) idz))))
        (PMM (when (not (or (> ox lx) (< oy hy) (< oz hz)
                            (plusp (+ (- (* dydx hx) hy) cxy))
                            (minusp (+ (- (* dxdy ly) lx) cyx))
                            (plusp (+ (- (* dydz lz) hy) czy))
                            (plusp (+ (- (* dzdy ly) hz) cyz))
                            (plusp (+ (- (* dzdx hx) hz) cxz))
                            (minusp (+ (- (* dxdz lz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- hy oy) idy)
                    (* (- hz oz) idz))))
        (PMP (when (not (or (> ox hx) (< oy ly) (> oz hz)
                            (plusp (+ (- (* dydx hx) hy) cxy))
                            (minusp (+ (- (* dxdy ly) lx) cyx))
                            (plusp (+ (- (* dydz hz) hy) czy))
                            (minusp (+ (- (* dzdy ly) lz) cyz))
                            (minusp (+ (- (* dzdx hx) lz) cxz))
                            (minusp (+ (- (* dxdz hz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- hy oy) idy)
                    (* (- lz oz) idz))))
        (PPM (when (not (or (> ox hx) (> oy hy) (< oz lz)
                            (minusp (+ (- (* dydx hx) ly) cxy))
                            (minusp (+ (- (* dxdy hy) lx) cyx))
                            (minusp (+ (- (* dydz lz) ly) czy))
                            (plusp (+ (- (* dzdy hy) hz) cyz))
                            (plusp (+ (- (* dzdx hx) hz) cxz))
                            (minusp (+ (- (* dxdz lz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- ly oy) idy)
                    (* (- hz oz) idz))))
        (PPP (when (not (or (> ox hx) (> oy hy) (> oz hz)
                            (minusp (+ (- (* dydx hx) ly) cxy))
                            (minusp (+ (- (* dxdy hy) lx) cyx))
                            (minusp (+ (- (* dydz hz) ly) czy))
                            (minusp (+ (- (* dzdy hy) lz) cyz))
                            (minusp (+ (- (* dzdx hx) lz) cxz))
                            (minusp (+ (- (* dxdz hz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- ly oy) idy)
                    (* (- lz oz) idz))))
        (OMM (when (not (or (< ox lx) (> ox hx)
                            (< oy ly) (< oz lz)
                            (plusp (+ (- (* dydz lz) hy) czy))
                            (plusp (+ (- (* dzdy ly) hz) cyz))))
               (max (* (- hy oy) idy)
                    (* (- hz oz) idz))))
        (OMP (when (not (or (< ox lx) (> ox hx)
                            (< oy ly) (< oz hz)
                            (plusp (+ (- (* dydz hz) hy) czy))
                            (minusp (+ (- (* dzdy ly) lz) cyz))))
               (max (* (- hy oy) idy)
                    (* (- lz oz) idz))))
        (OPM (when (not (or (< ox lx) (> ox hx)
                            (> oy hy) (< oz lz)
                            (minusp (+ (- (* dydz lz) ly) czy))
                            (plusp (+ (- (* dzdy hy) hz) cyz))))
               (max (* (- ly oy) idy)
                    (* (- hz oz) idz))))
        (OPP (when (not (or (< ox lx) (> ox hx)
                            (> oy hy) (> oz hz)
                            (minusp (+ (- (* dydz hz) ly) czy))
                            (minusp (+ (- (* dzdy hy) lz) cyz))))
               (max (* (- ly oy) idy)
                    (* (- lz oz) idz))))
        (MOM (when (not (or (< oy ly) (> oy hy)
                            (> ox lx) (< oz lz)
                            (plusp (+ (- (* dzdx lx) hz) cxz))
                            (plusp (+ (- (* dxdz lz) hx) czx))))
               (max (* (- hx ox) idx)
                    (* (- hz oz) idz))))
        (MOP (when (not (or (< oy ly) (> oy hy)
                            (< ox lx) (> oz hz)
                            (minusp (+ (- (* dzdx lx) lz) cxz))
                            (plusp (+ (- (* dxdz hz) hx) czx))))
               (max (* (- hx ox) idx)
                    (* (- lz oz) idz))))
        (POM (when (not (or (< oy ly) (> oy hy)
                            (> ox hx) (< oz lz)
                            (plusp (+ (- (* dzdx hx) hz) cxz))
                            (minusp (+ (- (* dxdz lz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- hz oz) idz))))
        (POP (when (not (or (< oy ly) (> oy hy)
                            (> ox hx) (> oz hz)
                            (minusp (+ (- (* dzdx hx) lz) cxz))
                            (minusp (+ (- (* dxdz hz) lx) czx))))
               (max (* (- lx ox) idx)
                    (* (- lz oz) idz))))
        (MMO (when (not (or (< oz lz) (> oz hz)
                            (< ox lx) (< oy ly)
                            (plusp (+ (- (* dydx lx) hy) cxy))
                            (plusp (+ (- (* dxdy ly) hx) cyx))))
               (max (* (- hx ox) idx)
                    (* (- hy oy) idy))))
        (MPO (when (not (or (< oz lz) (> oz hz)
                            (< ox lx) (> oy hy)
                            (minusp (+ (- (* dydx lx) ly) cxy))
                            (plusp (+ (- (* dxdy hy) hx) cyx))))
               (max (* (- hx ox) idx)
                    (* (- ly oy) idy))))
        (PMO (when (not (or (< oz lz) (> oz hz)
                            (> ox hx) (< oy ly)
                            (plusp (+ (- (* dydx hx) hy) cxy))
                            (minusp (+ (- (* dxdy ly) lx) cyx))))
               (max (* (- lx ox) idx)
                    (* (- hy oy) idy))))
        (PPO (when (not (or (< oz lz) (> oz hz)
                            (> ox hx) (> oy hy)
                            (minusp (+ (- (* dydx hx) ly) cxy))
                            (minusp (+ (- (* dxdy hy) lx) cyx))))
               (max (* (- lx ox) idx)
                    (* (- ly oy) idy))))
        (MOO (when (not (or (< ox lx) (< oy ly) (> oy hy) (< oz lz) (> oz hz)))
               (* (- hx ox) idx)))
        (POO (when (not (or (> ox hx) (< oy ly) (> oy hy) (< oz lz) (> oz hz)))
               (* (- lx ox) idx)))
        (OMO (when (not (or (< oy ly) (< ox lx) (> ox hx) (< oz lz) (> oz hz)))
               (* (- hy oy) idy)))
        (OPO (when (not (or (> oy hy) (< ox lx) (> ox hx) (< oz lz) (> oz hz)))
               (* (- ly oy) idy)))
        (OOM (when (not (or (< oz lz) (< ox lx) (> ox hx) (< oy ly) (> oy hy)))
               (* (- hz oz) idz)))
        (OOP (when (not (or (> oz hz) (< ox lx) (> ox hx) (< oy ly) (> oy hy)))
               (* (- lz oz) idz)))
        (t nil)))))



;; (defmacro foo (case flags)
;;   (flet ((pm (i) (if (logbitp (- 6 i) flags) 'plusp 'minusp )))
;;     `(,case (when (not (or (< ox lx) (< oy ly) (< oz lz)
;;                            (,(pm 0) (+ (- (* dydx lx) hy) cxy))
;;                            (,(pm 1) (+ (- (* dxdy ly) hx) cyx))
;;                            (,(pm 2) (+ (- (* dydz lz) hy) czy))
;;                            (,(pm 3) (+ (- (* dzdy ly) hz) cyz))
;;                            (,(pm 4) (+ (- (* dzdx lx) hz) cxz))
;;                            (,(pm 5) (+ (- (* dxdz lz) hx) czx))))
;;               (max (* (- hx ox) idx) 
;;                    (* (- hy oy) idy)
;;                    (* (- hz oz) idz))))))

;; (defmacro no-O-generator (case flags)
;;   (let ((first-args second-args))
;;     `(when (not (or ,@first-args ,@second-args)))))




